/* //Task_1
let x = 5;
alert(x++); // 5
//============================================================================================
//Task_2
let a = [] + false - null + true;
alert(a); //NaN */
/* Т.к. операторы + и - имеют одинаковый приоритет, они 
выполняются последовательно, слева - направо, отсюда
Ход решения:
	1. Сначала выполняется оператор "+", из пустого массива
получаем пустую строку, пустая строка + булевый false даёт
конкатенацию строк, в итоге получаем строку "false";
	2. Затем из строки "false" вычитается объект null,
	оба они преобразуются к числовому типу, из строки "false"
	получаем NaN, а из null значение 0, следовательно NaN - 0 == NaN;
	3. Потом к числового NaN прибавляем булевое true, они оба преобразуются
	к числовому типу и получаем, из true получаем 1, а NaN + 1 == NaN.
*/
//============================================================================================
/* //Task_3
let b = 1,
		c = b = 2;
alert(c); // 2 */
/* 
Сначало идет присваивание b = 1, затем значение 2 присваивается b, а потом
значение b присваивается c. 
*/
//============================================================================================
/* // Task_4
let d = [] + 1 + 2;
alert(d); //12 */
/* Первый бинарный + выдаёт строку "1", затем строка "1" складывается с числом 2,
происходит конкатенация строк, итог 12.*/
/* 
//============================================================================================
// Task_5  ??????????
alert("1"[0]); // 1  */
/* 
Как получается 1 не знаю, никакого оператора между ними нет, получается, что нулевой
элемент массива игнорируется?
*/
/*
//============================================================================================
// Task_6
console.log(2 && 1 && null && 0 && undefined); // null */
/*
Здесь 2 == true, 1 == true, null == false, возвращает null (не булевое значение),
!!!если я правильно понял, то для сравнения значения сначала преобразуются в булевый тип,
затем сравниваются и возвращается первое значение, которое при сравнении булевых типов даёт false
*/
//============================================================================================
// Task_7
/*	Есть ли разница между выражениями? !!( a && b ) и (a && b)?
Есть, из скобок возвращается значение либо a, либо b, 
1. Если "a" false, а "b" true, то возвращается а;
2. Если "а" true, а "b" false, то возвращается b;
3. Если оба false, возвращается a;
4. Если оба true, возвращается b;
Первое выражение - !!(a && b) возращает булевое значение либо a, либо b;
Второе выражение - (a && b) возращает одно значение либо a, либо b.
*/
//============================================================================================
// Task_8
// alert(null || 2 && 3 || 4) // 3
/*
Сначала выполнится оператор И, т.к. он имеет выше приоритет, чем оператор ИЛИ
Выражение 2 && 3 вернет 3, последний true,
Затем идет сравнение null || 3 || 4, null - false, 3 - true, дальше проверка останавливается
и возвращается 3.
*/
//============================================================================================
// Task_9  ??????????
/* let a = [1, 2, 3],
		b = [1, 2, 3];
	console.log(!!a); // true
	console.log(!!b); // true
	console.log(a == b); // false
alert(a == b); // false */
/*
Здесь не знаю, почему false, оба объекта в булевом значении true,
а при равенстве выдают false???????? 
*/
//============================================================================================
/* // Task_10
alert(+"Infinity"); //Infinity */
// Строка "infinity" с помощью унарного оператора + преобразуется в число,
//значение которого равно Infinity(бесконечность).
//============================================================================================
/* // Task_11
alert("ёжик" > "яблоко"); // true */
//Верно, здесь идёт сравнение побуквенно с учётом кодировки, значение буквы "ё" в кодировке
//больше значение буквы "я", дальше сравнение прекращается и ответ true;
//============================================================================================
/* // Task_12
console.log(0 || "" || 2 || undefined || true || falsе); //2
// Здесь все значение преобразуются в булевые значение и начинается выполняться оператор ИЛИ,
//Первый ИЛИ выдаст false, т.к. 0 и пустая строкая при преобразовании в булевый тип
//выдают false, затем идёт второй ИЛИ, где число 2 в буловом значении true, на этом всё заканчивается
//возвращается значение 2. */
